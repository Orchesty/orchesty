dbrp "pipes"."default"

var sample = 5s
var retention = '5s'

var bridgeData = stream
   |from()
       .database('pipes')
       .retentionPolicy('default')
       .measurement('pipes_node')
   |barrier()
       .period(sample)
   |window()
       .period(sample)
       .every(sample)
   |groupBy('topology_id', 'node_id')

// Total Processes
var total = bridgeData
   |count('bridge_job_result_success')

var totalFailed = bridgeData
   |where(lambda: "bridge_job_result_success" == FALSE)
   |count('bridge_job_result_success')

// Bridge data
var waitingTimeAvg = bridgeData
    |mean('bridge_job_waiting_duration')
        .as('time')

var timeMinWaiting = bridgeData
    |min('bridge_job_waiting_duration')
        .as('waiting')

var timeMinProcess = bridgeData
    |min('bridge_job_total_duration')
        .as('process')

var timeMin = timeMinWaiting
    |join(timeMinProcess)
        .as('waiting', 'process')
    |eval(lambda: "waiting.waiting", lambda: "process.process")
        .as('waiting', 'process')

var timeMaxWaiting = bridgeData
    |max('bridge_job_waiting_duration')
        .as('waiting')

var timeMaxProcess = bridgeData
    |max('bridge_job_total_duration')
        .as('process')

var timeMax = timeMaxWaiting
    |join(timeMaxProcess)
        .as('waiting', 'process')
    |eval(lambda: "waiting.waiting", lambda: "process.process")
        .as('waiting', 'process')

var processTimeAvg = bridgeData
    |mean('bridge_job_total_duration')
        .as('time')

total
   |join(totalFailed, waitingTimeAvg, timeMin, timeMax, processTimeAvg)
       .as('total', 'failed', 'avg_waiting', 'job_min', 'job_max', 'avg_process')
   |influxDBOut()
       .database('pipes')
       .measurement('bridges')
       .precision('ms')
       .retentionPolicy(retention)
