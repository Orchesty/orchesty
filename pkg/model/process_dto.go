package model

import (
	"errors"
	"fmt"
	"github.com/hanaboso/pipes/bridge/pkg/enum"
	"github.com/hanaboso/pipes/bridge/pkg/utils/stringx"
	"github.com/rs/zerolog"
	"github.com/streadway/amqp"
	"strconv"
)

const headerPrefix = "pf"

type ProcessDto struct {
	body    string
	headers map[string]string
	ack     func() error
	nack    func() error
}

func (dto ProcessDto) GetHeader(header string) (string, error) {
	value, ok := dto.headers[prefix(header)]
	if !ok {
		return "", fmt.Errorf("requested header [%s] does not exist", header)
	}

	return value, nil
}

func (dto ProcessDto) GetHeaderOrDefault(header, defaultValue string) string {
	value, err := dto.GetHeader(header)
	if err != nil {
		return defaultValue
	}

	return value
}

func (dto ProcessDto) GetIntHeader(header string) (int, error) {
	value, err := dto.GetHeader(header)
	if err != nil {
		return 0, err
	}

	ivalue, err := strconv.Atoi(value)
	if err != nil {
		return 0, fmt.Errorf("header [%s] of value [%s] was expected to be an integer", header, value)
	}

	return ivalue, nil
}

func (dto ProcessDto) GetIntHeaderOrDefault(header string, defaultValue int) int {
	value, err := dto.GetIntHeader(header)
	if err != nil {
		return defaultValue
	}

	return value
}

func (dto *ProcessDto) SetHeader(key, value string) *ProcessDto {
	if dto.headers == nil {
		dto.headers = make(map[string]string)
	}

	dto.headers[prefix(key)] = value

	return dto
}

func (dto *ProcessDto) Ack() error {
	return dto.ack()
}

func (dto *ProcessDto) Nack() error {
	return dto.nack()
}

func (dto *ProcessDto) IntoAmqp() amqp.Publishing {
	return amqp.Publishing{
		ContentType: "text/plain",
		Headers:     stringx.IntoInterfaceMap(dto.headers),
		Body:        []byte(dto.body),
	}
}

// Adds node data -> best to use as .EmbedObject(dto)
func (dto ProcessDto) MarshalZerologObject(e *zerolog.Event) {
	// TODO Review again after https://hanaboso.atlassian.net/wiki/spaces/PIP/pages/2804875265/Node#Headers
	e.Str("correlationId", dto.GetHeaderOrDefault(string(enum.Header_CorrelationId), ""))
	e.Str("processId", dto.GetHeaderOrDefault(string(enum.Header_ProcessId), ""))
	e.Str("topologyId", dto.GetHeaderOrDefault(string(enum.Header_TopologyId), ""))
	// TODO make sure that node-id is updated in time (right after consumer sends the message) so it's not previous node-id
	e.Str("nodeId", dto.GetHeaderOrDefault(string(enum.Header_NodeId), ""))
}

func prefix(header string) string {
	return fmt.Sprintf("%s-%s", headerPrefix, header)
}

type DtoBuilder struct {
	body    string
	headers map[string]string
	ack     func() error
	nack    func() error
}

func (b *DtoBuilder) Body(body string) *DtoBuilder {
	b.body = body

	return b
}

func (b *DtoBuilder) Header(key, value string) *DtoBuilder {
	b.initHeaders()
	b.headers[key] = value

	return b
}

func (b *DtoBuilder) Ack(ack func() error) *DtoBuilder {
	b.ack = ack

	return b
}

func (b *DtoBuilder) Nack(nack func() error) *DtoBuilder {
	b.nack = nack

	return b
}

func (b *DtoBuilder) Build() (ProcessDto, error) {
	if b.ack == nil {
		return ProcessDto{}, errors.New("message requires ack function")
	}
	if b.nack == nil {
		return ProcessDto{}, errors.New("message requires nack function")
	}
	b.initHeaders()
	// TODO validate required headers ? ... correlationId is generated by starting point? ... processId, ...

	return ProcessDto{
		body:    b.body,
		headers: b.headers,
		ack:     b.ack,
		nack:    b.nack,
	}, nil
}

func (b *DtoBuilder) initHeaders() {
	if b.headers == nil {
		b.headers = make(map[string]string)
	}
}
